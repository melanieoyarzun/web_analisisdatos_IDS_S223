{
  "hash": "43ba3698f831f48e7440402c150f043e",
  "result": {
    "markdown": "---\ninstitute: Magíster en Data Science - Universidad del Desarrollo\nsubtitle: 'Curso: Análisis de datos'\ntitle: 'Sesión 3: Introducción al análisis de regresión'\nauthor: 'Phd (c) Melanie Oyarzún - [melanie.oyarzun@udd.cl](mailto:melanie.oyarzun@udd.cl)'\nformat:\n  revealjs:\n    logo: logo_udd.png\n    footer: Curso Análisis de Datos - Sesión 3\n    transition: fade\n    background-transition: fade\n    fontsize: 1.8em\n    theme:\n      - simple\n      - custom.scss\n    chalkboard:\n      theme: whiteboard\n      boardmarker-width: 5\n      buttons: true\n    progress: true\n    incremental: true\n    scrollable: true\ncode-link: true\neditor:\n  markdown:\n    wrap: 100\necho: true\noutput-location: fragment\nexecute:\n  freeze: auto\ntoc-depth: 2\ndf-print: paged\n---\n\n<style>\n  table {\n    font-size: 0.7em; /* Reducir el tamaño de fuente en las tablas al 70% del tamaño base */\n  }\n</style>\n\n\n## El análisis de regresión\n\n- En las aplicaciones de la ciencia de datos, es muy común estar interesado en la relación entre dos o más variables.\n  \n- El análisis de regresión es una técnica en la cual buscamos encontrar una función que pueda describir la relación observada en los datos entre dos o mas variables.\n- Por ejemplo, podríamos querer relacionar los pesos de los individuos con sus alturas...\n  -  ¿son los más altos, más pesados?\n  -  y... ¿cuánto más pesados?\n\n## El análisis de regresión: Regresión Simple\n\n- Caso más sencillo: univariada o **regresión lineal simple**. \n  - Una variable que deseamos explicar o predecir (Y) como función de otra (X).\n  - Buscamos la pendiente e intercepto de una funciónla recta de la forma:\n\n. . .\n\n  $$Y = \\alpha + \\beta X$$\n  \n  donde:\n\n  - Y es la variale dependiente o que deseamos entender\n  - X es la variable independiente\n  - $\\beta$ es la pendiente de la recta\n  - $\\alpha$ es la constante o intersección (el valor de y cuando x=0)\n\n## El análisis de regresión\n\nBuscamos los **coeficientes** de la función entre Y y X: **constante** y **pendiente**\n\n\n```{=html}\n<img src=\"./img/img_sesion3/gif_regresion2.gif\"  style=\"display: block; margin: 0 auto;\">\n```\n\n\n## El análisis de regresión\n\nPara esto, pensamos que la variable que deseamos entender (Y, variable dependiente) se puede descomponer en dos partes: \n\n- una que es **sistemática** o que se puede explicar directamente con una o más variables independientes (Xs o regresores) \n\n- y otra que es **no sistemática** o error ($\\mu$ o $epsilon$) , que es aquella parte que no se puede explicar  y representa a la aleatoriedad del fenómeno.\n\n. . .\n\n\n```{=html}\n<img src=\"./img/img_sesion3/gif_regresion1.gif\" style=\"display: block; margin: 0 auto;\">\n\n```\n\n## El análisis de regresión\n\n\n```{=html}\n<img src=\"./img/img_sesion3/gif_regresion1.gif\" width=\"600\" style=\"display: block; margin: 0 auto;\">\n\n```\n\n. . . \n\nLa parte sistemática entonces la describimos con una **forma funcional**, que depende de otras variables o regresores. \n\n. . .\n\nEsta forma funcional puede:\n\n- ser lineal univariada,\n-  lineal múltiple o \n-  no lineal. \n\n. . .\nEl tipo de forma funcional, definirá el tipo de regresión de la que estemos hablando.\n\n## El análisis de regresión\n\nVentajas del análisis de regersión: es facil decsribir cuantitaivamente una rlación.\n\nEsquemáticamente, los elementos son:\n\n![](img/img_sesion3/regresion_esquema.png)\n\n## ¿Para qué hacer regresiones?\n\nPodemos pensar en tres uso, al menos, del análisis d eregresión:\n\n- Describir cuantitativamente una relación empírica\n- Probar hipótesis sobre ciertas teorías\n- Realizar predicciones \n\n\n## Regresión simple y scatterplot\n\n- Por ejemplo, pensemos en la relación entre los años de educación y el ingreso de las personas. Este ha sido un tema constante de estudio en diversas disciplinas, especialmente economía.\n\n- Usemos un subconjunto de datos de la encuesta CASEN 2022.\n\n. . . \n\n::: {#b6b25673 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n# cargamos los datos, es un subconjunto de pregungas, solo mayores de 18 años\n\ncasen_2022 = pd.read_stata(\"data/small_casen2022.dta\")\n# casen_2022 = pd.read_stata(\"https://github.com/melanieoyarzun/web_analisisdatos_IDS_S223/blob/main/data/small_casen2022.dta)\n\ncasen_2022.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id_vivienda</th>\n      <th>folio</th>\n      <th>id_persona</th>\n      <th>region</th>\n      <th>area</th>\n      <th>nse</th>\n      <th>expr</th>\n      <th>tot_per_h</th>\n      <th>edad</th>\n      <th>sexo</th>\n      <th>pco1_a</th>\n      <th>e3</th>\n      <th>o6</th>\n      <th>o8</th>\n      <th>y1</th>\n      <th>ytrabajocor</th>\n      <th>esc</th>\n      <th>desercion</th>\n      <th>educ</th>\n      <th>contrato</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1000901</td>\n      <td>100090101</td>\n      <td>1</td>\n      <td>Región de Ñuble</td>\n      <td>Rural</td>\n      <td>Bajo-medio</td>\n      <td>43</td>\n      <td>3</td>\n      <td>72</td>\n      <td>2. Mujer</td>\n      <td>No</td>\n      <td>2. No</td>\n      <td>2. No</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>1.0</td>\n      <td>NaN</td>\n      <td>Básica incompleta</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1000901</td>\n      <td>100090101</td>\n      <td>2</td>\n      <td>Región de Ñuble</td>\n      <td>Rural</td>\n      <td>Bajo-medio</td>\n      <td>43</td>\n      <td>3</td>\n      <td>67</td>\n      <td>1. Hombre</td>\n      <td>Sí</td>\n      <td>2. No</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>4.0</td>\n      <td>NaN</td>\n      <td>Básica incompleta</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1000901</td>\n      <td>100090101</td>\n      <td>3</td>\n      <td>Región de Ñuble</td>\n      <td>Rural</td>\n      <td>Bajo-medio</td>\n      <td>44</td>\n      <td>3</td>\n      <td>40</td>\n      <td>2. Mujer</td>\n      <td>No</td>\n      <td>2. No</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>No sabe</td>\n      <td>411242.0</td>\n      <td>15.0</td>\n      <td>NaN</td>\n      <td>Técnico nivel superior completo</td>\n      <td>No sabe</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1000902</td>\n      <td>100090201</td>\n      <td>1</td>\n      <td>Región de Ñuble</td>\n      <td>Rural</td>\n      <td>Bajo-medio</td>\n      <td>51</td>\n      <td>4</td>\n      <td>56</td>\n      <td>1. Hombre</td>\n      <td>No</td>\n      <td>2. No</td>\n      <td>2. No</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>No sabe</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1000902</td>\n      <td>100090201</td>\n      <td>2</td>\n      <td>Región de Ñuble</td>\n      <td>Rural</td>\n      <td>Bajo-medio</td>\n      <td>51</td>\n      <td>4</td>\n      <td>25</td>\n      <td>2. Mujer</td>\n      <td>No</td>\n      <td>2. No</td>\n      <td>2. No</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>12.0</td>\n      <td>Deserción</td>\n      <td>Media humanista completa</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Regresión simple y scatterplot\n\nY lo agruparemos por región, para facilitar el ejemplo:\n\n. . .\n\n::: {#bee0149b .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\n\n# Supongamos que tienes un DataFrame llamado 'data' con las columnas 'region', 'ytrabajocor', 'esc' y 'desercion'\n\n# Agrupar por 'region' y aplicar funciones de agregación\ncasen_2022_region = casen_2022.groupby('region').agg({'ytrabajocor': 'mean', 'esc': 'mean'}).reset_index()\n\n# Ahora contiene los resultados agregados por región\n\ncasen_2022_region.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>region</th>\n      <th>ytrabajocor</th>\n      <th>esc</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Región de Tarapacá</td>\n      <td>658026.6250</td>\n      <td>11.679582</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Región de Antofagasta</td>\n      <td>791351.8125</td>\n      <td>11.833934</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Región de Atacama</td>\n      <td>666128.3125</td>\n      <td>11.126735</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Región de Coquimbo</td>\n      <td>656137.8750</td>\n      <td>10.973584</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Región de Valparaíso</td>\n      <td>611298.1250</td>\n      <td>11.559877</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Regresión simple y scatterplot\n\nRealicemos un scatter sencillo:\n\n::: panel-tabset\n\n## matplotlib\n\n::: {#ea17dca4 .cell execution_count=3}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# Suponiendo que casen_2022 es tu DataFrame\nplt.scatter( casen_2022_region['esc'], casen_2022_region['ytrabajocor'],)\nplt.ylabel('ytrabajocor')\nplt.xlabel('esc')\nplt.title('Scatter Plot entre ytrabajocor y esc (por región)')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-4-output-1.png){width=845 height=448}\n:::\n:::\n\n\n## seaborn\n\n::: {#1e18fe65 .cell execution_count=4}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Suponiendo que casen_2022 es tu DataFrame\nsns.scatterplot(data=casen_2022_region, y='ytrabajocor', x='esc')\nplt.ylabel('ytrabajocor')\nplt.xlabel('esc')\nplt.title('Scatter Plot entre ytrabajocor y esc')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-5-output-1.png){width=845 height=448}\n:::\n:::\n\n\n## seaborn + linea de regresion\n\n::: {#edb2564c .cell execution_count=5}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Suponiendo que casen_2022 es tu DataFrame\nsns.regplot(data=casen_2022_region, y='ytrabajocor', x='esc', ci=95, line_kws={'color': 'magenta'})  # El argumento ci controla el intervalo de confianza\nplt.ylabel('ytrabajocor')\nplt.xlabel('esc')\nplt.title('Scatter Plot con Línea de Regresión y Intervalo de Confianza')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-6-output-1.png){width=845 height=448}\n:::\n:::\n\n\n## Con codigos de region\n\n::: {#14be71c6 .cell execution_count=6}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Suponiendo que casen_2022_region es tu DataFrame\nsns.regplot(data=casen_2022_region, y='ytrabajocor', x='esc', ci=95, line_kws={'color': 'magenta'})  # El argumento ci controla el intervalo de confianza\n\n# Procesar y agregar etiquetas de región a los puntos\nfor i, label in enumerate(casen_2022_region['region']):\n    last_word = label.split()[-1]  # Obtener la última palabra de la etiqueta\n    plt.text(casen_2022_region['esc'][i], casen_2022_region['ytrabajocor'][i], last_word, fontsize=8, ha='left', va='bottom')\n\nplt.ylabel('ytrabajocor')\nplt.xlabel('esc')\nplt.title('Scatter Plot con Línea de Regresión y Etiquetas de Región (Última Palabra)')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-7-output-1.png){width=853 height=451}\n:::\n:::\n\n\n:::\n\n\nPodemos ver que se aprecia una relación positiva: a mayor escolaridad promedio, mayor salario promedio por región.\n\n\n## Especificación\n\nLlamamos especifiación al precisar la relación entre las variables que deseamos estimar.\n. . . \n\nEn nuestro caso, la función base que queremos entender es entre salario y educación:\n. . . \n\n$$ \\text{Salario} = f(Educacion))$$\n\n. . . \n\nEste es una relación teorica entre variables aleatorias, porque no hemos especificado tres elementos cruciales:\n\n- agregar el error aleatorio\n- especificar una forma funcional\n- definir una forma de medir las variables en los datos\n\n. . .\n\nEn nuestro caso, entonces el modelo especificado sería:\n\n. . . \n$$ \\text{ingreso del trabajo}_i = \\alpha + \\beta \\text{años educación}_i + \\mu_i$$\n\n## Interpretación\n\nCon nuestro modelo especificado:\n\n$$ \\text{ingreso del trabajo}_i = \\alpha + \\beta \\text{años educación}_i + \\mu_i$$\n\nPodemos interpretar $\\beta$ y $alpha$:\n\n- $\\beta = \\frac{\\partial ingr}{\\partial educ}$: un año adiciónal de educación, en cuanto incrementa el salario (si nada más cambia) \n\n- $\\alpha$ valor esperado de y, si x=0...\n  \n## Modelo poblaciónal y estimación\n\nEste modelo especificado esta definido en la población:\n\n$$ \\text{ingreso del trabajo}_i = \\alpha + \\beta \\text{años educación}_i + \\mu_i$$\n\npero necesitamos calcularlo con la muestra.... por lo cual tenemos estimadores para los coeficientes poblacionales!\n\n$$\\hat{ \\text{ingreso del trabajo}}_i = \\hat{\\alpha} + \\hat{\\beta} \\text{años educación}_i $$\n\n\n## Modelo poblaciónal y estimación\n\nEl método más comun de estimación es el de los **mínimos cuadrados ordinarios**. Veremos detalles sobre la estimación, supuestos, propiedades estadísticas la proxima sesión.\n\nPor ahora, pensaremos que es el método que busca la línea que produce menores residuos, es decir, menor diferencia entre evalor predicho (linea de regresión).\n\n$$ \\hat{\\mu}_i= y_i-\\hat{y}_i$$\n\n::: {#756cc0f4 .cell execution_count=7}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport statsmodels.api as sm\n\n# Suponiendo que casen_2022_region es tu DataFrame\nsns.set(style='whitegrid')  # Configuración del estilo del gráfico\n\n# Agregar una columna de constante al DataFrame\ncasen_2022_region['constante'] = 1\n\n# Crear el gráfico de dispersión con la línea de regresión\nsns.regplot(data=casen_2022_region, y='ytrabajocor', x='esc', ci=95, line_kws={'color': 'magenta'}, scatter_kws={'color': 'blue'})  # El argumento ci controla el intervalo de confianza\n\n# Ajustar el modelo de regresión lineal\ny = casen_2022_region['ytrabajocor']\nX = casen_2022_region[['esc', 'constante']]  # 'constante' es la columna que agregamos para el término constante\nmodelo = sm.OLS(y, X).fit()\n\n# Calcular las predicciones ('ytrabajocor_pred') a partir del modelo\ncasen_2022_region['ytrabajocor_pred'] = modelo.predict(X)\n\n# Agregar líneas que conecten cada punto a la línea de regresión\nfor i in range(len(casen_2022_region)):\n    x_point = casen_2022_region['esc'][i]\n    y_point = casen_2022_region['ytrabajocor'][i]\n    y_pred = casen_2022_region['ytrabajocor_pred'][i]  # Usamos las predicciones del modelo\n    \n    # Línea que conecta el punto a la línea de regresión\n    plt.plot([x_point, x_point], [y_point, y_pred], linestyle='--', color='gray')\n\nplt.ylabel('ytrabajocor')\nplt.xlabel('esc')\nplt.title('Lineas de regresión y residuos')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-8-output-1.png){width=845 height=448}\n:::\n:::\n\n\nEs decir, minimiza $$\\sum_{i}^{n} \\hat{\\mu}_i $$\n\n## Modelo estimado\n\nPor ahora, solo estimaremos el modelo directamente usando statsmodels\n\n::: panel-tabset\n\n## Agrupados por región\n\n::: {#6e896a94 .cell execution_count=8}\n``` {.python .cell-code}\nimport pandas as pd\nimport statsmodels.api as sm\n\n# Supongamos que 'casen_2022' contiene las columnas 'ytrabajocor' (variable dependiente) y 'esc' (variable independiente),\n# y que puedes tener valores NaN en tus datos.\n\n# Eliminar filas con valores NaN\ncasen_2022_clean = casen_2022_region.dropna(subset=['ytrabajocor', 'esc'])\n\n# Agregar una columna de constantes para el término constante en el modelo\ncasen_2022_clean['constante'] = 1\n\n# Definir las variables dependiente e independiente\ny = casen_2022_clean['ytrabajocor']\nX = casen_2022_clean[['constante', 'esc']]  # Usar 'constante' como término constante\n\n# Ajustar el modelo de regresión lineal\nmodelo = sm.OLS(y, X).fit()\n\n# Imprimir un resumen del modelo\nprint(modelo.summary())\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:            ytrabajocor   R-squared:                       0.563\nModel:                            OLS   Adj. R-squared:                  0.532\nMethod:                 Least Squares   F-statistic:                     18.07\nDate:                Sat, 09 Sep 2023   Prob (F-statistic):           0.000808\nTime:                        11:26:49   Log-Likelihood:                -201.85\nNo. Observations:                  16   AIC:                             407.7\nDf Residuals:                      14   BIC:                             409.3\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P>|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nconstante  -7.467e+05   3.29e+05     -2.272      0.039   -1.45e+06   -4.17e+04\nesc         1.258e+05   2.96e+04      4.250      0.001    6.23e+04    1.89e+05\n==============================================================================\nOmnibus:                        0.030   Durbin-Watson:                   1.473\nProb(Omnibus):                  0.985   Jarque-Bera (JB):                0.151\nSkew:                          -0.072   Prob(JB):                        0.927\nKurtosis:                       2.547   Cond. No.                         189.\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n```\n:::\n:::\n\n\n## Todos los datos\n\n::: {#a6664d09 .cell execution_count=9}\n``` {.python .cell-code}\nimport pandas as pd\nimport statsmodels.api as sm\n\n# Supongamos que 'casen_2022' contiene las columnas 'ytrabajocor' (variable dependiente) y 'esc' (variable independiente),\n# y que puedes tener valores NaN en tus datos.\n\n# Eliminar filas con valores NaN\ncasen_2022_clean = casen_2022.dropna(subset=['ytrabajocor', 'esc'])\n\n# Agregar una columna de constantes para el término constante en el modelo\ncasen_2022_clean['constante'] = 1\n\n# Definir las variables dependiente e independiente\ny = casen_2022_clean['ytrabajocor']\nX = casen_2022_clean[['constante', 'esc']]  # Usar 'constante' como término constante\n\n# Ajustar el modelo de regresión lineal\nmodelo = sm.OLS(y, X).fit()\n\n# Imprimir un resumen del modelo\nprint(modelo.summary())\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:            ytrabajocor   R-squared:                       0.135\nModel:                            OLS   Adj. R-squared:                  0.135\nMethod:                 Least Squares   F-statistic:                 1.371e+04\nDate:                Sat, 09 Sep 2023   Prob (F-statistic):               0.00\nTime:                        11:26:49   Log-Likelihood:            -1.3153e+06\nNo. Observations:               87910   AIC:                         2.631e+06\nDf Residuals:                   87908   BIC:                         2.631e+06\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P>|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nconstante  -2.701e+05   8430.418    -32.035      0.000   -2.87e+05   -2.54e+05\nesc         7.707e+04    658.196    117.100      0.000    7.58e+04    7.84e+04\n==============================================================================\nOmnibus:                   165004.626   Durbin-Watson:                   1.657\nProb(Omnibus):                  0.000   Jarque-Bera (JB):       1073370403.828\nSkew:                          13.789   Prob(JB):                         0.00\nKurtosis:                     543.626   Cond. No.                         42.3\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n```\n:::\n:::\n\n\n:::\n\nPodemos ver que un año adicional de educación ase asocia con 126.000/77.000 app pesos mensuales, el resto constante.\n\n¿y la constante, como la podemos interpretar?\n\n## Modelos simples y múltiples\n\nMuchas veces una sola variable no es suficiente para describir bien un fenómeno. Necesitamos incluir más variables.\n\nEsto puede ser:\n\n- Una nueva variable\n- Una forma funcional no lineal de la variable ya incluida\n\nNuestra interpretación del modelo no cambia, solo que ahora efectivamente estamos **controlando** por otros factores.\n\n## Modelos simples y múltiples\n\nProbemos, agregar edad al modelo:\n\n$$ \\text{ingreso del trabajo}_i = \\alpha + \\beta_1 \\text{años educación}_i + \\beta_2 \\text{edad}_i + \\mu_i$$\n\n::: {#9948dc16 .cell execution_count=10}\n``` {.python .cell-code}\nimport pandas as pd\nimport statsmodels.api as sm\n\n# Supongamos que 'casen_2022' contiene las columnas 'ytrabajocor' (variable dependiente) y 'esc' (variable independiente),\n# y que puedes tener valores NaN en tus datos.\n\n# Eliminar filas con valores NaN\ncasen_2022_clean = casen_2022.dropna(subset=['ytrabajocor', 'esc', 'edad'])\n\n# Agregar una columna de constantes para el término constante en el modelo\ncasen_2022_clean['constante'] = 1\n\n# Definir las variables dependiente e independiente\ny = casen_2022_clean['ytrabajocor']\nX = casen_2022_clean[['constante', 'esc', 'edad']]  # Usar 'constante' como término constante\n\n# Ajustar el modelo de regresión lineal\nmodelo = sm.OLS(y, X).fit()\n\n# Imprimir un resumen del modelo\nprint(modelo.summary())\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:            ytrabajocor   R-squared:                       0.150\nModel:                            OLS   Adj. R-squared:                  0.150\nMethod:                 Least Squares   F-statistic:                     7754.\nDate:                Sat, 09 Sep 2023   Prob (F-statistic):               0.00\nTime:                        11:26:49   Log-Likelihood:            -1.3145e+06\nNo. Observations:               87910   AIC:                         2.629e+06\nDf Residuals:                   87907   BIC:                         2.629e+06\nDf Model:                           2                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P>|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nconstante   -7.37e+05   1.45e+04    -50.839      0.000   -7.65e+05   -7.09e+05\nesc         8.792e+04    708.136    124.163      0.000    8.65e+04    8.93e+04\nedad        7591.3242    192.583     39.419      0.000    7213.864    7968.784\n==============================================================================\nOmnibus:                   165576.617   Durbin-Watson:                   1.666\nProb(Omnibus):                  0.000   Jarque-Bera (JB):       1120061445.830\nSkew:                          13.885   Prob(JB):                         0.00\nKurtosis:                     555.280   Cond. No.                         272.\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n```\n:::\n:::\n\n\n## Modelos simples y múltiples\n\nEs muy usual, agregar edad al cuadrado.... para representar que los salarios crecen con la edad hasta cierto punto, y luego empieza a decaer...\n\n$$ \\text{ingreso del trabajo}_i = \\alpha + \\beta_1 \\text{años educación}_i + \\beta_2 \\text{edad}_i  + \\beta_3 \\text{edad}^2_i + \\mu_i$$\n\n::: {#ea665be2 .cell execution_count=11}\n``` {.python .cell-code}\nimport pandas as pd\nimport statsmodels.api as sm\n\n# Supongamos que 'casen_2022' contiene las columnas 'ytrabajocor' (variable dependiente), 'esc' (variable independiente),\n# 'edad' (variable independiente) y puedes tener valores NaN en tus datos.\n\n# Eliminar filas con valores NaN\ncasen_2022_clean = casen_2022.dropna(subset=['ytrabajocor', 'esc', 'edad'])\n\n# Agregar una columna de constantes para el término constante en el modelo\ncasen_2022_clean['constante'] = 1\n\n# Agregar una columna con 'edad' al cuadrado\ncasen_2022_clean['edad_cuadrado'] = casen_2022_clean['edad'] ** 2\n\n# Definir las variables dependiente e independiente\ny = casen_2022_clean['ytrabajocor']\nX = casen_2022_clean[['constante', 'esc', 'edad', 'edad_cuadrado']]  # Incluye 'edad_cuadrado'\n\n# Ajustar el modelo de regresión lineal\nmodelo = sm.OLS(y, X).fit()\n\n# Imprimir un resumen del modelo\nprint(modelo.summary())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:            ytrabajocor   R-squared:                       0.157\nModel:                            OLS   Adj. R-squared:                  0.157\nMethod:                 Least Squares   F-statistic:                     5454.\nDate:                Sat, 09 Sep 2023   Prob (F-statistic):               0.00\nTime:                        11:26:49   Log-Likelihood:            -1.3142e+06\nNo. Observations:               87910   AIC:                         2.628e+06\nDf Residuals:                   87906   BIC:                         2.628e+06\nDf Model:                           3                                         \nCovariance Type:            nonrobust                                         \n=================================================================================\n                    coef    std err          t      P>|t|      [0.025      0.975]\n---------------------------------------------------------------------------------\nconstante     -1.273e+06   2.46e+04    -51.789      0.000   -1.32e+06   -1.23e+06\nesc            8.514e+04    712.733    119.463      0.000    8.37e+04    8.65e+04\nedad           3.529e+04   1045.445     33.754      0.000    3.32e+04    3.73e+04\nedad_cuadrado  -302.7647     11.234    -26.950      0.000    -324.784    -280.746\n==============================================================================\nOmnibus:                   166354.248   Durbin-Watson:                   1.665\nProb(Omnibus):                  0.000   Jarque-Bera (JB):       1155260651.345\nSkew:                          14.028   Prob(JB):                         0.00\nKurtosis:                     563.898   Cond. No.                     2.46e+04\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n[2] The condition number is large, 2.46e+04. This might indicate that there are\nstrong multicollinearity or other numerical problems.\n```\n:::\n:::\n\n\n## Ya no es lineal el modelo?\n\nOjo! La linealidad es en los parámetros, no en las variables. \n\nLa siguiente ecuación muestra un modelo lineal en el que el predictor  𝑥1  no es lineal respecto a y:\n\n$y = \\beta_0 + \\beta_1x_1 + \\beta_2log(x_1) + \\epsilon$\n\n\n<img src=\"./img/img_sesion3/im1.png\" width=\"400\">\n\nEn contraposición, el siguiente no es un modelo lineal:\n\n$y = \\beta_0 + \\beta_1x_1^{\\beta_2} + \\epsilon$\n\n## Ya no es lineal el modelo?\n\nEn ocasiones, algunas relaciones no-lineales pueden transformarse de forma que se pueden expresar de manera lineal:\n\n- Modelo no-lineal a estimar: $y = \\beta_0x_1^{\\beta_1}\\epsilon$\n\n- Solucion: pasamos todo a logaritmos:\n\n$$log(y)=log(\\beta_0) + \\beta_1log(x_1) + log(\\epsilon)$$\n        \n$$y^{'}=\\beta_0^{'}+\\beta_1x_1^{'} + \\epsilon^{'}$$\n\n- Estimar el modelo y extraer los coeficientes.\n\n- Volvera a la forma funcional incial exponenciando los logaritmos.\n    - $\\beta_1$ es explicito.\n    - $\\beta_0^{'}=log(\\beta_0)=> exp(log(\\beta_0))$\n\n## Un poco más sobre interpretación\n\nElementos clave en la interpretación de un modelo de regresión lineal:\n\n- $\\beta_0$: Ordenada en el origen, valor esperado de $y$ cuando todos los predictores son cero.\n- $\\beta_j$: Coeficientes de regresión parcial de cada predictor, representan el cambio promedio esperado en $y$ al aumentar en una unidad $x_j$, manteniendo otros predictores constantes (\"ceteris paribus\").\n\n## Un poco más sobre interpretación: Magnitud\n\nLos coeficientes están medidos en las unidades que se está trabajando.\n\n![](img/img_sesion3/unidad_medida.png)\n\n**Importancia de coeficientes parciales estandarizados:**\n- Se obtienen al estandarizar las variables predictoras antes del ajuste del modelo.\n- $\\beta_0$ refleja el valor esperado de $y$ cuando los predictores están en su promedio.\n- $\\beta_j$ indica el cambio promedio esperado en $y$ al aumentar en una desviación estándar $x_j$, manteniendo otros predictores constantes.\n\n\n## Causalidad, regresión y correlación\n\n**Importante tener en cuenta:**\n\n- Antes de intentar ajustar un modelo lineal a los datos observados, la persona debe determinar primero **si existe o no una relación entre las variables** de interés.\n- Esto no implica necesariamente que una variable cause la otra (por ejemplo, puntajes más altos en la PSU no causan calificaciones superiores en la universidad), pero existe alguna asociación significativa entre las dos variables.\n- Un diagrama de dispersión puede ser una herramienta útil para determinar la fuerza de la relación entre dos variables.\n  \n## Causalidad, regresión y correlación\n\n**Importante tener en cuenta:**\n\n- Si parece no haber asociación entre las variables explicativas y dependiente propuestas (es decir, el diagrama de dispersión no indica ninguna tendencia creciente o decreciente),\n\n  - entonces ajustar un modelo de regresión lineal a los datos probablemente no proporcionará un modelo útil.\n  - Una valiosa medida numérica de asociación entre dos variables es el coeficiente de correlación, que es un valor entre -1 y 1 que indica la fuerza de la asociación de los datos observados para las dos variables.\n\n\n## Una perspectiva histórica:\n\n- El origen de la técnica, podemos remontarlo a la genética.\n\n- Francis Galton estudió la variación y la herencia de los rasgos humanos. Entre muchos otros rasgos, Galton recolectó y estudió datos de altura de familias para tratar de entender la herencia. **Mientras hacía esto, desarrolló los conceptos de correlación y regresión.**\n- Pregunta: **¿qué tan bien podemos predecir la estatura de un niño basado en la estatura de los padres?**\n- La técnica que desarrolló para responder a esta pregunta, la regresión, también puede aplicarse en muchas otras circunstancias.\n\n## Una perspectiva histórica:\n\n::: columns\n:::column\n<img src=\"./img/img_sesion3/galton.png\" width=\"400\">\n:::\n\n:::column\n**Nota histórica:**\n\n- Galton hizo importantes contribuciones a la estadística y la genética…\n- pero también fue uno de los primeros defensores de la **eugenesia**…\n- un movimiento filosófico científicamente defectuoso favorecido por muchos biólogos de la época de Galton, pero con terribles consecuencias históricas.\n:::\n:::\n\n## Estudio de caso: ¿es hereditaria la altura?\n\n- Tenemos acceso a los datos de altura de familias recolectado por Galton, a través del paquete `HistData`.\n\n- Estos datos contienen las alturas de varias docenas de familias: madres, padres, hijas e hijos.\n\n. . .\n\n:::{.panel-tabset}\n## Cargar datos\n\n::: {#d422c8a0 .cell execution_count=12}\n``` {.python .cell-code}\n# Cargamos los paquetes que vamos a usar\nimport statsmodels.api as sm\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\n\n# Si no tiene stats models, instalar: pip install statsmodels\n\n# Cargar el conjunto de datos GaltonFamilies\ngalton_data = sm.datasets.get_rdataset(\"GaltonFamilies\", package=\"HistData\").data\n\n# Mostrar las primeras filas del DataFrame\nprint(galton_data.head(4))\n```\n:::\n\n\n## Tabla de datos\n\n::: {#cfc4ba3f .cell execution_count=13}\n\n::: {.cell-output .cell-output-display execution_count=53}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>family</th>\n      <th>father</th>\n      <th>mother</th>\n      <th>midparentHeight</th>\n      <th>children</th>\n      <th>childNum</th>\n      <th>gender</th>\n      <th>childHeight</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>001</td>\n      <td>78.5</td>\n      <td>67.0</td>\n      <td>75.43</td>\n      <td>4</td>\n      <td>1</td>\n      <td>male</td>\n      <td>73.2</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>001</td>\n      <td>78.5</td>\n      <td>67.0</td>\n      <td>75.43</td>\n      <td>4</td>\n      <td>2</td>\n      <td>female</td>\n      <td>69.2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>001</td>\n      <td>78.5</td>\n      <td>67.0</td>\n      <td>75.43</td>\n      <td>4</td>\n      <td>3</td>\n      <td>female</td>\n      <td>69.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>001</td>\n      <td>78.5</td>\n      <td>67.0</td>\n      <td>75.43</td>\n      <td>4</td>\n      <td>4</td>\n      <td>female</td>\n      <td>69.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n:::\n\n## Análisis de caso: ¿es hereditaria la altura?\n\nPara imitar el análisis de Galton, crearemos un conjunto de datos con las alturas de los padres y un hijo de cada familia seleccionado al azar:\n\n. . .\n\n:::{.panel-tabset}\n## Cargar datos\n\n::: {#8443b477 .cell execution_count=14}\n``` {.python .cell-code}\n# Filtrar por género masculino y seleccionar una muestra de una altura de hijo por familia\ngalton_heights = galton_data[galton_data['gender'] == 'male']\\\n    .groupby('family')\\\n    .apply(lambda group: group.sample(n=1))\\\n    .reset_index(drop=True)\\\n    .loc[:, ['father', 'childHeight']]\\\n    .rename(columns={'childHeight': 'son'})\n\ngalton_heights.head()\n```\n:::\n\n\n## Tabla de datos\n\n::: {#0f80e767 .cell execution_count=15}\n\n::: {.cell-output .cell-output-display execution_count=55}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>father</th>\n      <th>son</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>78.5</td>\n      <td>73.2</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>75.5</td>\n      <td>73.5</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>75.0</td>\n      <td>71.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>75.0</td>\n      <td>68.5</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>75.0</td>\n      <td>68.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n:::\n\n\n## Estudio de caso: ¿es hereditaria la altura?\n\n- Supongamos que se nos pidiera que resumiéramos (describieramos) los datos de padres e hijos.\n\n- Como ambas distribuciones están aproximadas por la distribución normal, podríamos usar los dos promedios y dos desviaciones estándar como resúmenes:\n\n. . .\n\n::: {#0d38cc6b .cell execution_count=16}\n``` {.python .cell-code}\npromedio_padre = galton_heights['father'].mean()\nsd_padre = galton_heights['father'].std()\npromedio_hijo = galton_heights['son'].mean()\nsd_hijo = galton_heights['son'].std()\n\nresumen_estadistico = pd.DataFrame({\n    'promedio_padre': [promedio_padre],\n    'sd_padre': [sd_padre],\n    'promedio_hijo': [promedio_hijo],\n    'sd_hijo': [sd_hijo]\n})\n\nprint(resumen_estadistico)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   promedio_padre  sd_padre  promedio_hijo   sd_hijo\n0       69.098883  2.546555      69.248045  2.680733\n```\n:::\n:::\n\n\nSin embargo, este resumen no describe una característica importante de los datos: \n\n**la tendencia de que cuanto más alto es el padre, más alto es el hijo.**\n\n## Estudio de caso: ¿es hereditaria la altura?\n\n:::{.panel-tabset}\n## Code\n\n::: {#3cd2637f .cell execution_count=17}\n``` {.python .cell-code}\nimport pandas as pd\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Configurar el tamaño de la figura\nplt.figure(figsize=(10, 6))\n\n# Cargar el conjunto de datos GaltonFamilies\ngalton_data = sm.datasets.get_rdataset(\"GaltonFamilies\", package=\"HistData\").data\n\n# Filtrar por género masculino y seleccionar una muestra de una altura de hijo por familia\ngalton_heights = galton_data[galton_data['gender'] == 'male']\\\n    .groupby('family')\\\n    .apply(lambda group: group.sample(n=1))\\\n    .reset_index(drop=True)\\\n    .loc[:, ['father', 'childHeight']]\\\n    .rename(columns={'childHeight': 'son'})\n\n# Crear el gráfico de dispersión con línea de regresión\nsns.set(style=\"whitegrid\")\nsns.scatterplot(data=galton_heights, x='father', y='son', alpha=0.5, size=3)\nsns.regplot(data=galton_heights, x='father', y='son', scatter=False)\n\nplt.xlabel(\"Altura del Padre\")\nplt.ylabel(\"Altura del Hijo\")\nplt.title(\"Relación entre Altura del Padre y Altura del Hijo\")\n\n# Mostrar el gráfico\nplt.show()\n```\n:::\n\n\n## Plot\n\n::: {#18134db5 .cell execution_count=18}\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-19-output-1.png){width=824 height=520}\n:::\n:::\n\n\n:::\n\n## ¿Regresión? ¿Y la correlación?\n\n::: columns\n::: column\n- Ambos están muy relacionados.\n- Aprenderemos que el coeficiente de correlación es un resumen informativo de cómo dos variables se mueven juntas…\n- y luego veremos cómo esto puede ser usado para predecir una variable usando la otra y modelado en una regresión\n:::\n\n::: column\n\n::: {#a2635078 .cell execution_count=19}\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-20-output-1.png){width=812 height=520}\n:::\n:::\n\n\n:::\n\n:::\n\n## Taller de aplicación 2: \n### Caso aplicación: Cursos de Verano\n\n::: callout-tip\n## **Taller de aplicación 2: Pregunta 1**\n\n- Considere los datos trabajados en el taller 1, sobre los cursos de verano. Recordemos la pregunta que queríamos responder:\n\n- **Asistir a cursos de verano mejora los resultados académicos?**\n\n1.  Plantee un modelo de regresión con los datos disponibles  que deseamos estimar.\n2.   Grafique la dispersión y la recta de regresión estimada.\n\n:::\n\n## El coeficiente de correlación\n\nEl coeficiente de correlación se define para una lista de pares $(x_1,y_1),...(x_n,y_n)$  como la media de los productos de los valores normalizados:\n\n$$\n\\rho = \\frac{1}{n}\\sum_{i=1}^{n} \\big(\\frac{x_i-\\mu_x }{\\sigma_x}\\big)\\big(\\frac{y_i-\\mu_y}{\\sigma_y}\\big)\n$$\n\nDónde $\\mu$ son promedios y $\\sigma$ son desviaciones estándar. La letra griega para r, $\\rho$ se utiliza comúnmente en los libros de estadística para denotar la correlación, porque es la primera letra de regresión. Pronto aprenderemos sobre la conexión entre correlación y regresión. \n\nPodemos representar la fórmula anterior con el código R usando:\n\n`rho <- mean(scale(x) * scale(y))`\n\nLa correlación entre las alturas del padre y del hijo es de aproximadamente $0,4$:\n\n## El coeficiente de correlación\n\n\nPodemos representar la fórmula anterior con el siguiente código usando:\n\n::: {#85409e20 .cell execution_count=20}\n``` {.python .cell-code}\nimport numpy as np\n\nx = np.array([1, 2, 3, 4, 5])  # Tu arreglo x aquí\ny = np.array([6, 7, 8, 9, 10])  # Tu arreglo y aquí\n\nrho = np.mean((x - np.mean(x)) * (y - np.mean(y))) / (np.std(x) * np.std(y))\n\nprint(rho)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.9999999999999998\n```\n:::\n:::\n\n\n## El coeficiente de correlación\n\nLa correlación entre las alturas del padre y del hijo es de aproximadamente $0,4$.\n\n::: {#6878a980 .cell execution_count=21}\n``` {.python .cell-code}\ncorrelation_coefficient = galton_heights[['father', 'son']].corr().iloc[0, 1]\nprint(\"Coeficiente de Correlación:\", correlation_coefficient)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoeficiente de Correlación: 0.4501189204142688\n```\n:::\n:::\n\n\n::: {#f6854ba9 .cell execution_count=22}\n``` {.python .cell-code}\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\nfrom sklearn.preprocessing import StandardScaler\n\n# Cargar el conjunto de datos GaltonFamilies\ngalton_data = sm.datasets.get_rdataset(\"GaltonFamilies\", package=\"HistData\").data\n\n# Filtrar por género masculino y seleccionar una muestra de una altura de hijo por familia\ngalton_heights = galton_data[galton_data['gender'] == 'male']\\\n    .groupby('family')\\\n    .apply(lambda group: group.sample(n=1))\\\n    .reset_index(drop=True)\\\n    .loc[:, ['father', 'childHeight']]\\\n    .rename(columns={'childHeight': 'son'})\n\n# Calcular la media y la desviación estándar de la altura del padre\nmean_scaled_father = StandardScaler().fit_transform(galton_heights[['father']]).mean()\nsd_scaled_father = StandardScaler().fit_transform(galton_heights[['father']]).std()\n\nmean_father = galton_heights['father'].mean()\nsd_father = galton_heights['father'].std()\n\nprint(\"Media de la Altura del Padre (Estandarizada):\", mean_scaled_father)\nprint(\"Desviación Estándar de la Altura del Padre (Estandarizada):\", sd_scaled_father)\nprint(\"Media de la Altura del Padre:\", mean_father)\nprint(\"Desviación Estándar de la Altura del Padre:\", sd_father)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMedia de la Altura del Padre (Estandarizada): 4.6046344887246715e-15\nDesviación Estándar de la Altura del Padre (Estandarizada): 1.0\nMedia de la Altura del Padre: 69.09888268156423\nDesviación Estándar de la Altura del Padre: 2.546555038637639\n```\n:::\n:::\n\n\n## El coeficiente de correlación\n\n::: {#a513a3f8 .cell execution_count=23}\n``` {.python .cell-code}\n# Calcular la correlación entre father y son usando una muestra de galton_heights\nR = galton_heights.sample(n=75, replace=True).corr().loc[\"father\", \"son\"]\nprint(R)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.5104684885147245\n```\n:::\n:::\n\n\nPara ver cómo se ven los datos para los diferentes valores de $\\rho$ aquí hay seis ejemplos de pares con correlaciones que van de -0,9 a 0,99:\n\n![image](img/img_sesion3/g1.png)\n\n## La correlación es variable aleatoria\n\nAntes de continuar conectando la correlación con la regresión, recordemos la variabilidad aleatoria.\n\nEn la mayoría de las aplicaciones de la ciencia de datos, observamos datos que incluyen **variación aleatoria**.\n\n\nA modo de ejemplo, supongamos que las 179 parejas de padres e hijos son toda nuestra población. Un genetista menos afortunado sólo puede costear las mediciones de una muestra aleatoria de 25 pares. La correlación de la muestra se puede calcular con:\n\n::: {#7245d1bf .cell execution_count=24}\n``` {.python .cell-code}\nimport pandas as pd\n\n# Seleccionar una muestra aleatoria de tamaño 75 con reemplazo\nR = galton_heights.sample(n=75, replace=True)\n\n# Calcular el coeficiente de correlación entre las columnas \"father\" y \"son\"\ncorrelation_coefficient = R[['father', 'son']].corr().iloc[0, 1]\n\nprint(\"Coeficiente de Correlación en la Muestra:\", correlation_coefficient)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoeficiente de Correlación en la Muestra: 0.5072834085504967\n```\n:::\n:::\n\n\n## \n\n\nR es una variable aleatoria. Podemos ejecutar una simulación de Monte Carlo para ver su distribución:\n\n* Nota: el objetivo principal de la simulación de Montecarlo es intentar imitar el comportamiento de variables reales para, en la medida de lo posible, analizar o predecir cómo van a evolucionar.\n\n::: {#4ad9e16d .cell execution_count=25}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nB = 1000\nN = 100\nR = np.zeros(B)\n\nfor i in range(B):\n    sample = galton_heights.sample(n=N, replace=False)\n    correlation_coefficient = sample[['father', 'son']].corr().iloc[0, 1]\n    R[i] = correlation_coefficient\n\n# Crear un histograma de los coeficientes de correlación\nplt.hist(R, bins=np.arange(-1, 1.1, 0.05), color='black')\nplt.xlabel(\"Coeficiente de Correlación\")\nplt.ylabel(\"Frecuencia\")\nplt.title(\"Histograma de Coeficientes de Correlación\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-26-output-1.png){width=820 height=448}\n:::\n:::\n\n\n## \n\n\nVemos que el valor esperado de R es la correlación de la población:\n\n::: {#53b21fed .cell execution_count=26}\n``` {.python .cell-code}\nmean_R = np.mean(R)\nprint(\"Media de Coeficientes de Correlación:\", mean_R)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMedia de Coeficientes de Correlación: 0.45842882440885\n```\n:::\n:::\n\n\ny que tiene un error estándar relativamente alto en relación con el rango de valores que puede tomar R:\n\n::: {#095e96d7 .cell execution_count=27}\n``` {.python .cell-code}\nsd_R = np.std(R)\nprint(\"Desviación Estándar de Coeficientes de Correlación:\", sd_R)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDesviación Estándar de Coeficientes de Correlación: 0.047460810230179874\n```\n:::\n:::\n\n\n## \n\n- Por lo tanto, al interpretar las correlaciones, recuerde que las correlaciones derivadas de las muestras son estimaciones que contienen incertidumbre.\n\n- Además, tenga en cuenta que debido a que la correlación de la muestra es un promedio de extracciones independientes, el teorema del límite central realmente funciona. \n- Por lo tanto, para $N$ lo suficientemente grande la distribución de $R$ es aproximadamente normal con el valor esperado $\\rho$. \n- La desviación estándar, que es algo compleja de derivar, es: $\\sqrt{\\frac{1-r^2}{N-2}}$.\n\n##\n\n- En nuestro ejemplo, $N=25$ no parece ser lo suficientemente grande para que la aproximación sea buena\n\n\n-Si N aumenta verás que la distribución converge a una normal.\n\n* Nota: El gráfico Q-Q, o gráfico cuantitativo, es una herramienta gráfica que nos ayuda a evaluar si un conjunto de datos proviene plausiblemente de alguna distribución teórica como una Normal o exponencial.\n\n::: {#5e4437cc .cell execution_count=28}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.stats as stats\n\n# Crear un DataFrame con los coeficientes de correlación\ndf_R = pd.DataFrame({'R': R})\n\n# Calcular la media y el tamaño de la muestra\nmean_R = np.mean(R)\nN = len(R)\n\n# Crear el gráfico QQ-plot\nplt.figure(figsize=(6, 6))\nstats.probplot(df_R['R'], dist='norm', plot=plt)\nplt.xlabel(\"Cuantiles Teóricos\")\nplt.ylabel(\"Cuantiles de R\")\nplt.title(\"Gráfico QQ-plot para los Coeficientes de Correlación\")\nplt.plot([np.min(R), np.max(R)], [np.min(R), np.max(R)], color='red')  # Línea de referencia\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-29-output-1.png){width=527 height=520}\n:::\n:::\n\n\n## La correlación no siempre es un resumen útil\n\nLa correlación no siempre es un buen resumen de la relación entre dos variables. Los siguientes cuatro conjuntos de datos artificiales, conocidos como el cuarteto de Anscombe, ilustran este punto. Todos estos pares tienen una correlación de 0,82:\n\n![image](img/img_sesion3/g2.png)\n\nLa correlación sólo tiene sentido en un contexto particular. Para ayudarnos a entender cuándo es que la correlación es significativa como estadística de resumen, volveremos al ejemplo de predecir la estatura del hijo usando la estatura del padre. Esto ayudará a motivar y definir la regresión lineal. Comenzamos demostrando cómo la correlación puede ser útil para la predicción.\n\n# Correlación no es causalidad\n\nLa asociación no es causalidad es quizás la lección más importante que se aprende en una clase de estadística. Hay muchas razones por las que una variable $X$ puede correlacionarse con una variable $Y$ sin tener ningún efecto directo sobre $Y$. Aquí examinamos tres maneras comunes que pueden llevar a una mala interpretación de los datos.\n\n## Correlación espuria\n\nVemos una fuerte correlación entre las tasas de divorcio y el consumo de margarina.\n\n\n![image](img/img_sesion3/notcausa.png)\n\n\n(Acá pueden encontrar más http://tylervigen.com/old-version.html)\n\n- ¿Significa esto que la margarina causa divorcios?  \n- ¿O los divorcios hacen que la gente coma más margarina? \n\n## La paradoja de Simpson\n\n- Se llama paradoja porque vemos el signo de la correlación cambiar cuando comparamos toda la data y estratos específicos. \n\n- Como ejemplo ilustrativo, supongamos que tiene tres variables aleatorias $X$, $Y$ y $Z$ y que observamos realizaciones de estas. \n- Aquí está el gráfico de observaciones simuladas para $X$ y $Y$ a lo largo de la correlación de la muestra:\n\n. . .\n\n<img src=\"./img/img_sesion3/simp1.png\" width=\"600\">\n\n## La paradoja de Simpson\n\n\n- Puedes ver que $X$ e $Y$ están negativamente correlacionados. \n- Sin embargo, una vez que estratificamos por $Z$ (mostrado en diferentes colores abajo) emerge otro patrón:\n\n. . . \n\n<img src=\"./img/img_sesion3/simp2.png\" width=\"600\">\n\n## La paradoja de Simpson\n\n<img src=\"./img/img_sesion3/simp2.png\" width=\"600\">\n\n- Es realmente $Z$ que está negativamente correlacionado con $X$. \n- Si estratificamos por $Z$ las variables $X$ e $Y$ están en realidad correlacionados positivamente como se ha visto en el gráfico anterior.\n\n## Expectativas condicionales\n\n- Supongamos que nos piden que adivinemos la altura de un hijo seleccionado al azar y no sabemos la altura de su padre.\n\n- Debido a que la distribución de las alturas de los hijos es aproximadamente normal, sabemos que la altura media, $69.2$, es el valor con la mayor proporción y sería la predicción con mayores posibilidades de minimizar el error.\n\n- Pero, ¿y si nos dicen que el padre es más alto que el promedio, digamos que mide 72 pulgadas de alto, todavía esperaríamos que la altura más probable del hijo sea 69.2 pulgadas?\n\n## expectativas condicionales\n\n- Resulta que si pudiéramos recolectar datos de un gran número de padres que miden 72 pulgadas...\n  - la distribución de las alturas de sus hijos sería normalmente distribuida. \n  - Esto implica que el promedio de la distribución calculada en este subconjunto sería nuestra mejor predicción.\n\n## expectativas condicionales\n\n- En general, llamamos a este enfoque condicional. \n- La idea general es que estratificamos una población en grupos y calculamos resúmenes en cada grupo. \n- Por lo tanto, el condicionamiento está relacionado con el concepto de estratificación descrito. \n\n- Porque la expectativa condicional $E(Y|X=x)$ es el mejor predictor para la variable aleatoria $Y$ para un individuo en los estratos definidos por  $X=x$ muchos de los desafíos de la ciencia de datos se reducen a la estimación de esta cantidad.\n\n## Expectativas condicionales\n\n\n- En el ejemplo que hemos estado considerando, estamos interesados en calcular la altura promedio del hijo condicionada a que el padre tenga 72 pulgadas de altura. \n\n- Queremos estimar $E(Y|X=72)$ usando la muestra recolectada por Galton. \n\n- ¿Cuantos padres miden 72?\n\n. . . \n\n::: {#425fd0f3 .cell execution_count=29}\n``` {.python .cell-code}\ncount_72 = (galton_heights['father'] == 72).sum()\nprint(\"Cantidad de registros con valor 72 en la columna 'father':\", count_72)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCantidad de registros con valor 72 en la columna 'father': 8\n```\n:::\n:::\n\n\n- Si cambiamos el número a 72.5, obtenemos aún menos puntos de datos:\n\n. . .\n\n::: {#533e140b .cell execution_count=30}\n``` {.python .cell-code}\ncount_725 = (galton_heights['father'] == 72.5).sum()\nprint(\"Cantidad de registros con valor 72.5 en la columna 'father':\", count_725)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCantidad de registros con valor 72.5 en la columna 'father': 1\n```\n:::\n:::\n\n\n## Expectativas condicionales\n\n- Una forma práctica de mejorar estas estimaciones de las expectativas condicionales, es definir estratos con valores similares de $x$.\n- En nuestro ejemplo, podemos redondear las alturas paternas a la pulgada más cercana y asumir que todas son de 72 pulgadas. \n- Si hacemos esto, terminamos con la siguiente predicción para el hijo de un padre que mide 72 pulgadas de alto:\n\n::: {#772507c7 .cell execution_count=31}\n``` {.python .cell-code}\nconditional_avg = galton_heights[galton_heights['father'].round() == 72]['son'].mean()\nprint(\"Promedio condicional para father == 72:\", conditional_avg)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPromedio condicional para father == 72: 70.44285714285715\n```\n:::\n:::\n\n\n## Expectativas condicionales\n\n- Note que un padre de 72 pulgadas es más alto que el promedio -- específicamente, 72 - 69.1/2.5 = 1.1 desviaciones estándar más alto que el padre promedio. \n- Nuestra predicción, $70.5$, es también más alta que el promedio, pero sólo $0.49$ desviaciones estándar más grandes que el hijo promedio. \n- Los hijos de padres de 72 pulgadas han regresado algunos a la estatura promedio.\n-  Observamos que la reducción en el número de SD más altas es de alrededor de $0.5$, lo que resulta ser la correlación. \n-  Como veremos en una sección posterior, esto no es una coincidencia.\n\n## Expectativas condicionales\n\n- Si queremos hacer una predicción de cualquier altura, no sólo de 72, podríamos aplicar el mismo enfoque a cada estrato. \n- La estratificación seguida de los boxplots nos permite ver la distribución de cada grupo:\n\n::: {#7500d793 .cell execution_count=32}\n``` {.python .cell-code}\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Supongamos que tienes un DataFrame llamado 'galton_heights' con las columnas 'father' y 'son'.\n\n# Crear una nueva columna 'father_strata' con los valores redondeados de 'father'\ngalton_heights['father_strata'] = galton_heights['father'].round().astype(int)\n\n# Crear el gráfico de boxplots\nplt.figure(figsize=(10, 6))  # Tamaño del gráfico\nsns.boxplot(data=galton_heights, x='father_strata', y='son')\n\n# Agregar puntos para mostrar las medias condicionadas\nsns.swarmplot(data=galton_heights, x='father_strata', y='son', color='black', size=4)\n\nplt.xlabel('father_strata')\nplt.ylabel('son')\nplt.title('Boxplots de son condicionado por father_strata con Medias Condicionadas')\nplt.xticks(rotation=45)  # Rotar etiquetas del eje x si es necesario\n\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-33-output-1.png){width=812 height=528}\n:::\n:::\n\n\n## Expectativas condicionales\n\nNo es de extrañar que los centros de los grupos aumenten con la altura.\n\n. . .\n\n::: {#716c2fb3 .cell execution_count=33}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Redondear los valores de la columna \"father\"\ngalton_heights['father'] = galton_heights['father'].round()\n\n# Calcular el promedio condicional de \"son\" para cada valor de \"father\"\nconditional_avg_by_father = galton_heights.groupby('father')['son'].mean().reset_index()\n\n# Crear un gráfico de puntos para mostrar el promedio condicional por \"father\"\nplt.figure(figsize=(10, 6))\nplt.scatter(conditional_avg_by_father['father'], conditional_avg_by_father['son'], color='blue')\nplt.xlabel(\"Father Height\")\nplt.ylabel(\"Conditional Son Height Average\")\nplt.title(\"Promedio Condicional de Alturas de Hijos por Altura de Padres\")\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-34-output-1.png){width=812 height=520}\n:::\n:::\n\n\n- Además, estos centros parecen seguir una relación lineal. \n\n## Expectativas condicionales\n\n- A continuación se presentan los promedios de cada grupo. \n- Si tenemos en cuenta que estos promedios son variables aleatorias con errores estándar, los datos son consistentes con estos puntos siguiendo una línea recta:\n\n::: {#0caa355f .cell execution_count=34}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Redondear los valores de la columna \"father\"\ngalton_heights['father'] = galton_heights['father'].round()\n\n# Calcular el promedio condicional de \"son\" para cada valor de \"father\"\nconditional_avg_by_father = galton_heights.groupby('father')['son'].mean().reset_index()\n\n\nconditional_avg_by_father.head()\n\n\n# Crear un gráfico de puntos con ajuste de regresión lineal\nplt.figure(figsize=(10, 6))\nsns.scatterplot(x='father', y='son', data=conditional_avg_by_father, color='blue')\nsns.regplot(x='father', y='son', data=conditional_avg_by_father, scatter=False, color='orange')\nplt.xlabel(\"Father Height\")\nplt.ylabel(\"Conditional Son Height Average\")\nplt.title(\"Promedio Condicional de Alturas de Hijos por Altura de Padres con Regresión Lineal\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-35-output-1.png){width=812 height=520}\n:::\n:::\n\n\n## Expectativas condicionales\n\n- El hecho de que estos promedios condicionales sigan una línea **no es una coincidencia**. \n- En la siguiente sección, explicamos que la línea que siguen estos promedios es lo que llamamos la línea de regresión, que mejora la precisión de nuestras estimaciones. \n- Sin embargo, no siempre es apropiado estimar las expectativas condicionales con la línea de regresión, por lo que también describimos la justificación teórica de Galton para usar la línea de regresión.\n\n\n\n## La línea/recta de regresión\n\n- Si estamos prediciendo una variable aleatoria $Y$ conociendo el valor de otra variable $X=x$ usando una línea de regresión, entonces predecimos que **para cada desviación estándar, $\\sigma_x$ que $x$ aumenta por encima de la media $\\mu_x$, $Y$ incrementa $\\rho$ veces la desviación estándar $\\sigma_Y$ sobre el promedio $\\mu_Y$**, con $\\rho$ la correlación entre $X$ e $Y$. Por lo tanto, la formula de la regresión es:\n\n$$\n\\left( \\frac{Y-\\mu_Y}{\\sigma_Y} \\right)=\\rho \\left(\\frac{x-\\mu_X}{\\sigma_X}\\right)\n$$\n\nLo que podemos reescribir como:\n\n$$\nY=\\mu_Y + \\rho \\big(\\frac{x-\\mu_X}{\\sigma_X}\\big) \\sigma_Y\n$$\n\n## La línea/recta de regresión\n\n- Si existe una correlación perfecta, la línea de regresión predice un aumento que corresponde al mismo número de desviacones estándar. \n\n- Si hay correlación 0, entonces no usamos $x$ en absoluto en la predicción y simplemente predecimos el promedio $\\mu_Y$. \n- Para valores entre 0 y 1, la predicción se encuentra en un punto intermedio. \n- Si la correlación es negativa, predecimos una reducción en lugar de un aumento.\n\n## Regresión a la media\n\n- Nótese que si la correlación es positiva e inferior a 1, nuestra predicción está más cerca (en unidades estándar) de la altura media que de lo que el valor utilizado para predecir, $x$, está del promedio de los $x$. \n- Por eso lo llamamos regresión: el hijo regresa a la estatura media.\n-  De hecho, el título del artículo de Galton era: Regresión a la mediocridad en la estatura hereditaria (Regression toward mediocrity in hereditary stature.). \n\n## La línea/recta de regresión\n\n- Para añadir líneas de regresión a los gráficos, necesitaremos la fórmula anterior en la forma: $y=b+mx$, con pendiente $m=\\rho \\sigma_y / \\sigma_x$ e intercepto $b=\\mu_y - m \\mu_x$\n\n- Aquí agregamos la línea de regresión a la data original.\n\n::: {#473b2797 .cell execution_count=35}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Cálculo de las medias y desviaciones estándar\nmu_x = galton_heights['father'].mean()\nmu_y = galton_heights['son'].mean()\ns_x = galton_heights['father'].std()\ns_y = galton_heights['son'].std()\n\n# Cálculo del coeficiente de correlación\nr = galton_heights['father'].corr(galton_heights['son'])\n\n# Cálculo de la pendiente y el intercepto para la línea de regresión\nm = r * s_y / s_x\nb = mu_y - m * mu_x\n\n# Configuración del tamaño de la figura\nplt.figure(figsize=(10, 6))\n\n# Crear un gráfico de dispersión con línea de regresión\nsns.scatterplot(x='father', y='son', data=galton_heights, alpha=0.5, size=3)\nsns.regplot(x='father', y='son', data=galton_heights, scatter=False, color='red', line_kws={'color': 'blue'})\nplt.xlabel(\"Father Height\")\nplt.ylabel(\"Son Height\")\nplt.title(\"Relación entre Altura de Padres e Hijos con Línea de Regresión\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-36-output-1.png){width=812 height=520}\n:::\n:::\n\n\n## La línea/recta de regresión\n\n- La fórmula de regresión implica que si primero estandarizamos las variables, es decir, restamos el promedio y dividimos por la desviación estándar, entonces la línea de regresión tiene intercepto 0 y pendiente igual a la correlación $\\rho$. \n- Aquí está la misma gráfica, pero usando unidades estándar:\n\n. . .\n\n::: {#ed03d6e7 .cell execution_count=36}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Supongamos que tienes un DataFrame llamado 'galton_heights' con las columnas 'father' y 'son'.\n\n# Estandarizar las variables 'father' y 'son'\ngalton_heights['father_standardized'] = (galton_heights['father'] - galton_heights['father'].mean()) / galton_heights['father'].std()\ngalton_heights['son_standardized'] = (galton_heights['son'] - galton_heights['son'].mean()) / galton_heights['son'].std()\n\n# Calcular la correlación de las variables estandarizadas\nr = galton_heights['father_standardized'].corr(galton_heights['son_standardized'])\n\n# Configuración del tamaño de la figura\nplt.figure(figsize=(10, 6))\n\n# Crear un gráfico de dispersión con línea de regresión\nsns.scatterplot(x='father_standardized', y='son_standardized', data=galton_heights, alpha=0.5, size=3)\nsns.regplot(x='father_standardized', y='son_standardized', data=galton_heights, scatter=False, color='red', line_kws={'color': 'blue'})\nplt.xlabel(\"Father Height (Standardized)\")\nplt.ylabel(\"Son Height (Standardized)\")\nplt.title(\"Relación Estandarizada entre Altura de Padres e Hijos con Línea de Regresión (Intercepto = 0, Pendiente = Correlación)\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-37-output-1.png){width=874 height=520}\n:::\n:::\n\n\n# Regresión: Definición matemática\n\n\nEl modelo de regresión lineal (Legendre, Gauss, Galton y Pearson) considera que, dado un conjunto de observaciones $\\{y_i, x_{i1},...,x_{np}\\}^{n}_{i=1}$ , la media  $𝜇$  de la variable respuesta  $𝑦$  se relaciona de forma lineal con la o las variables regresoras  $𝑥_1$ ... $x_p$  acorde a la ecuación:\n\n$$\\mu_y = \\beta_0 + \\beta_1 x_{1} + \\beta_2 x_{2} + ... + \\beta_p x_{p}$$\n \nEl resultado de esta ecuación se conoce como la línea de regresión poblacional, y recoge la relación entre los predictores y la media de la variable respuesta.\n\n# Regresión: Definición matemática\n\n\n- Otra definición que se encuentra con frecuencia en los libros de estadística es:\n\n$$y_i= \\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{i2} + ... + \\beta_p x_{ip} +\\epsilon_i$$\n \n- En este caso, se está haciendo referencia al valor de  𝑦  para una observación  𝑖  concreta. El valor de una observación puntual nunca va a ser exactamente igual al promedio, de ahí que se añada el término de error  $\\epsilon$.\n\n## Interpretación:\n\n\nEn ambos casos, la interpretación de los elementos del modelo es la misma:\n\n- $\\beta_0$: es la ordenada en el origen, se corresponde con el valor promedio de la variable respuesta  $y$  cuando todos los predictores son cero.\n\n- $\\beta_j$: es el efecto promedio que tiene sobre la variable respuesta el incremento en una unidad de la variable predictora  $x_j$, manteniéndose constantes el resto de variables. Se conocen como coeficientes de regresión.\n\n- $\\epsilon$: es el residuo o error, la diferencia entre el valor observado y el estimado por el modelo. Recoge el efecto de todas aquellas variables que influyen en $y$ pero que no se incluyen en el modelo como predictores.\n\n## Interpretación:\n\n- En la gran mayoría de casos, los valores $\\beta_0$ y $\\beta_j$ poblacionales se desconocen, por lo que, a partir de una muestra, se obtienen sus estimaciones  $\\hat{\\beta_0}$ y $\\hat{\\beta_j}$. \n- **Ajustar el modelo consiste en estimar, a partir de los datos disponibles, los valores de los coeficientes de regresión que maximizan la verosimilitud (likelihood), es decir, los que dan lugar al modelo que con mayor probabilidad puede haber generado los datos observados.**\n\n- El método empleado con más frecuencia es el **ajuste por mínimos cuadrados ordinarios (OLS)**\n  - que identifica como mejor modelo la recta (o plano si es regresión múltiple) \n  - que minimiza la suma de las desviaciones verticales entre cada dato de entrenamiento y la recta, elevadas al cuadrado.\n\n## Magnitud y significancia\n\n- La magnitud de cada coeficiente parcial de regresión depende de las unidades en las que se mida la variable predictora a la que corresponde, por lo que su magnitud no está asociada con la importancia de cada predictor.\n- Una buena practica es estandarizar\n\n\n## Cuidado: hay dos líneas de regresión\n\nCalculamos una línea de regresión para predecir la altura del hijo desde la altura del padre. \n\nUsamos estos cálculos:\n\n::: {#a2ace4f6 .cell execution_count=37}\n``` {.python .cell-code}\nimport numpy as np\n\n# Calcular la media de las alturas del padre\nmu_x = galton_heights['father'].mean()\n\n# Calcular la media de las alturas del hijo\nmu_y = galton_heights['son'].mean()\n\n# Calcular la desviación estándar de las alturas del padre\ns_x = galton_heights['father'].std()\n\n# Calcular la desviación estándar de las alturas del hijo\ns_y = galton_heights['son'].std()\n\n# Calcular el coeficiente de correlación entre las alturas del padre y el hijo\nr = galton_heights['father'].corr(galton_heights['son'])\n\n\n\nprint(r)\nprint(s_x)\nprint(s_y)\nprint(mu_x)\nprint(mu_y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.4658308243792417\n2.56441709039222\n2.6076529186746025\n69.08938547486034\n69.263687150838\n```\n:::\n:::\n\n\n::: {#661a543e .cell execution_count=38}\n``` {.python .cell-code}\n# Calcular la pendiente de la primera línea de regresión\nm_1 = r * s_y / s_x\n\n# Calcular el intercepto de la primera línea de regresión\nb_1 = mu_y - m_1 * mu_x\n\nprint(\"pendiente\", m_1)\nprint(\"constante\", b_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npendiente 0.47368468778038647\nconstante 36.53710316324001\n```\n:::\n:::\n\n\n## Cuidado: hay dos líneas de regresión\n\n- ¿Y si queremos predecir la estatura del padre basándonos en la del hijo? \n\n- Es importante saber que esto no se determina calculando la función inversa!.\n\n- Necesitamos computar $E(X∣Y=y)$. Dado que los datos son aproximadamente normales bivariados, la teoría descrita anteriormente nos dice que esta expectativa condicional seguirá una línea con pendiente e intercepto:\n\n::: {#040e5bca .cell execution_count=39}\n``` {.python .cell-code}\nm_2 = r * s_x / s_y\nb_2 = mu_x - m_2 * mu_y\n\nprint(\"pendiente\", m_2)\nprint(\"constante\", b_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npendiente 0.4581071808731349\nconstante 37.35919301731116\n```\n:::\n:::\n\n\n## Cuidado: hay dos líneas de regresión\n\n- Aquí hay un gráfico que muestra las dos líneas de regresión:\n\n- con azul para la predicción de las alturas del hijo con las alturas del padre y rojo para la predicción de las alturas del padre con las alturas del hijo.\n\n\n::: panel-tabset\n\n## Codigo\n\n::: {#3d525a74 .cell execution_count=40}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Crear el gráfico utilizando Matplotlib y Seaborn\nplt.figure(figsize=(10, 6))\nsns.scatterplot(data=galton_heights, x='father', y='son', alpha=0.5)\nplt.plot(galton_heights['father'], b_1 + m_1 * galton_heights['father'], color='blue', label='y = b_1 + m_1 * x')\nplt.plot(galton_heights['father'], -b_2/m_2 + 1/m_2 * galton_heights['father'], color='red', label='y = -b_2/m_2 + 1/m_2 * x')\nplt.legend()\nplt.xlabel('Father Height')\nplt.ylabel('Son Height')\nplt.title('Scatter Plot with Regression Lines')\nplt.show()\n```\n:::\n\n\n## plot\n\n::: {#9f5f84d2 .cell execution_count=41}\n\n::: {.cell-output .cell-output-display}\n![](sesion3_slides_files/figure-revealjs/cell-42-output-1.png){width=812 height=520}\n:::\n:::\n\n\n:::\n\n\n## Taller aplicación 2: ALtura de madres, padres, hijos e hijas\n::: callout-tip\n\n## Taller aplicacción 2: Altura de madres, padres, hijos e hijas\n\n\n1) Cargue los datos de `GaltonFamilies` desde el HistData. Los niños de cada familia están ordenados por sexo y luego por estatura. Cree un conjunto de datos llamado `galton_heights` seleccionando niños y niñas al azar. (HINT: use `sample`).\n\n2) Haga una gráfica para las alturas entre madres e hijas, madres e hijos, padres e hijas, y padres e hijos.\n\n3) Calcular la correlación para alturas entre madres e hijas, madres e hijos, padres e hijas, y padres e hijos.\n\n4) Plotear las correalciones sobre cada grafica defindia en 2 (linea de regresion).\n\n5) Obtener el modelo de regresión e interpretar los coeficientes.\n:::\n\n",
    "supporting": [
      "sesion3_slides_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}